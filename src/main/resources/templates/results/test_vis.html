<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
  <meta charset="UTF-8">
  <th:block th:insert="~{fragments/heading :: heading (title = 'Test Visiualisation')}"/>

  <!--  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">-->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <style>
    body { font-family: system-ui, sans-serif; }
    #chart { max-height: 480px; }
    .metric-list { max-height: 300px; overflow-y: auto; border: var(--bs-border-width) solid var(--bs-border-color); padding: .75rem; border-radius: .5rem; }
    .metric-list label { display: flex; align-items: center; gap: .35rem; font-weight: 500; cursor: pointer; }
  </style>
</head>

<body class="p-4">

<h2>Test report: <span th:text="${uuid}">uuid-placeholder</span></h2>

<div class="row gy-3 mb-3">
  <div class="row gy-3 mb-3 align-items-end">

    <!-- generate-report button -->
    <div class="col-md-2 order-md-last text-md-end mb-2" th:if="${#authorization.expression('hasRole(''TECHNICIAN'')')}">
      <a th:href="@{/technician/reports/new/{testUuid} (testUuid=${uuid})}">
        Create report
      </a>

      <!--    <a th:href="@{/technician/customers/{custId}/bikes/{custBikeId}/reports/create/{testUuid}-->
      <!--    (custId=${customerId}, custBikeId=${custBikeId}, testUuid=${uuid})}">-->
      <!--      Create report-->
      <!--    </a>-->


    </div>

  </div>
</div>


<div class="row gy-3 mb-3">

  <div class="col-md-7">
    <p class="fw-semibold mb-1">Select up to 4 metrics</p>
    <div id="metricBox" class="metric-list"></div>
    <small class="text-muted">More than four? Un-tick one first.</small>
  </div>

  <div class="col-md-3 align-self-start">
    <div class="form-check mb-3 mt-4">
      <input class="form-check-input" type="checkbox" id="normaliseChk">
      <label class="form-check-label fw-semibold" for="normaliseChk">
        Normalised (0-100 %)
      </label>
    </div>
  </div>

  <div class="col-md-2 align-self-start">
    <label for="intervalSelect" class="form-label fw-semibold">Interval</label>
    <select id="intervalSelect" class="form-select">
      <option value="1">1 s</option>
      <option value="10">10 s</option>
      <option value="60">1 min</option>
      <option value="300">5 min</option>
    </select>
  </div>
</div>

<canvas id="chart"></canvas>

<script th:inline="javascript">
  const uuid = /*[[${uuid}]]*/ 'dev';                 // injected by controller
  const maxSeries = 4;                                // upper bound per chart

  async function fetchRows() {
    const rsp = await fetch('/api/report/' + uuid);
    console.log(rsp);
    if (!rsp.ok) throw new Error('Cannot load report: ' + rsp.status);
    return rsp.json();
  }

  function buildMetricBoxes(rows) {
    const ignore = ['uuid','timestamp','statusPlug'];
    const metrics = Object.keys(rows[0]).filter(k => !ignore.includes(k));

    const box = document.getElementById('metricBox');
    metrics.forEach(k => {
      const id = 'chk_' + k;
      const lbl = k.replace(/([A-Z])/g,' $1').replace(/^./,c=>c.toUpperCase());
      const wrapper = document.createElement('label');
      wrapper.innerHTML = `
       <input type="checkbox" class="form-check-input metric" id="${id}" value="${k}">
       <span>${lbl}</span>`;
      box.appendChild(wrapper);
    });
  }

  const normalise = arr => {
    const min = Math.min(...arr), max = Math.max(...arr);
    return arr.map(v => (v - min) * 100 / (max - min || 1));
  };

  function resample(rows, bucketSec) {
    if (bucketSec === 1) return rows;

    const ignore = ['uuid','timestamp','statusPlug'];
    const keys = Object.keys(rows[0]).filter(k => !ignore.includes(k));
    const buckets = new Map();

    rows.forEach(r => {
      const tsMs = Date.parse(r.timestamp);
      const bucketStart = Math.floor(tsMs/1000 / bucketSec) * bucketSec; // seconds
      let acc = buckets.get(bucketStart);
      if (!acc) {
        acc = { count:0 };
        keys.forEach(k => acc[k] = 0);
        buckets.set(bucketStart, acc);
      }
      acc.count++;
      keys.forEach(k => acc[k] += +r[k]);
    });

    const out = [];
    buckets.forEach((acc, t) => {
      const obj = { timestamp: new Date(t*1000).toISOString() };
      keys.forEach(k => obj[k] = acc[k] / acc.count);
      out.push(obj);
    });
    out.sort((a,b) => Date.parse(a.timestamp) - Date.parse(b.timestamp));
    return out;
  }

  function createChart(allRows) {
    const ctx = document.getElementById('chart');
    const chart = new Chart(ctx, {
      type: 'line',
      data: { labels: [], datasets: [] },
      options: {
        interaction: { mode:'nearest', axis:'x', intersect:false },
        maintainAspectRatio: false,
        scales: { x: { title:{display:true, text:'Time'} } }
      }
    });

    function refresh() {
      /* get UI state */
      const checked = [...document.querySelectorAll('.metric:checked')];
      if (checked.length > maxSeries) {
        checked[checked.length-1].checked = false;
        return;
      }
      const metrics = checked.map(c => c.value);
      const norm = normaliseChk.checked;
      const bucketSec = +intervalSelect.value;

      /* resample rows, rebuild labels */
      const rows = resample(allRows, bucketSec);
      const timeFmt = bucketSec >= 60 ? 'HM' : 'HMS'; // abbrev for formatting
      const labels = rows.map(r => {
        const [date, time] = r.timestamp.split('T');
        return timeFmt === 'HMS'
                ? time.split('.')[0]
                : time.slice(0,5);
      });

      chart.data.labels = labels;

      chart.data.datasets = metrics.map((key, idx) => {
        const raw = rows.map(r => +r[key]);
        const axis = norm ? 'y' : 'y'+idx;

        if (!chart.options.scales[axis]) {
          chart.options.scales[axis] = {
            type: 'linear',
            position: idx%2 ? 'right':'left',
            title: { display:true, text:key },
            grid : norm ? {} : { drawOnChartArea:false }
          };
        }
        return {
          label: key,
          data : norm ? normalise(raw) : raw,
          yAxisID: axis,
          tension: 0.25,
          pointRadius: 0
        };
      });

      if (norm) {
        Object.keys(chart.options.scales)
                .filter(k => k.startsWith('y') && k!=='y')
                .forEach(k => delete chart.options.scales[k]);
      }
      chart.update();
    }

    document.getElementById('metricBox')    .addEventListener('change', refresh);
    document.getElementById('normaliseChk') .addEventListener('change', refresh);
    document.getElementById('intervalSelect').addEventListener('change', refresh);

    ['batteryVoltage','batteryCurrent','enginePowerWatt','wheelPowerWatt']
            .forEach(id => { const chk = document.querySelector('#chk_'+id); if (chk) chk.checked = true; });

    refresh();
  }

  fetchRows()
          .then(rows => { buildMetricBoxes(rows); createChart(rows); })
          .catch(err  => { alert(err.message); console.error(err); });
</script>

</body>
</html>